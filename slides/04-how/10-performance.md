<!-- .slide: data-auto-animate -->

### Performance

For every mutation we run the whole test suite once.
<!-- .element: class="fragment semi-fade-out" data-fragment-index="1" -->

**T<sub>total</sub>** = T<sub>test</sub> &times; N<sub>mutants</sub>
<!-- .element class="fragment semi-fade-out" data-fragment-index="1" style="text-align: center" -->

We need to be smarter!
<!-- .element class="fragment" data-fragment-index="1" -->

**T<sub>total</sub>** < T<sub>test</sub> &times; N<sub>mutants</sub>
<!-- .element class="fragment" data-fragment-index="1" style="text-align: center" -->

---

<!-- .slide: data-auto-animate -->

### Performance

Three approaches to improving performance

* 🏎️ Do **faster**<span class="fragment" data-fragment-index="1">: 27 studies</span>
* 🦥 Do **fewer**<span class="fragment" data-fragment-index="1">: 118 studies</span>
* 🧐 Do **smarter**<span class="fragment" data-fragment-index="1">: 75 studies</span>

A. Pizzoleto, F. Ferrari, J. Offutt, L. Fernandes, and M. Ribeiro, “A systematic literature
review of techniques and metrics to reduce the cost of mutation testing,” Journal of Systems
and Software, vol. 157, Jul. 2019. DOI: 10.1016/j.jss.2019.07.100.

<!-- .element class="kc-smallest" -->

---

### Common techniques

<div class="kc-columns kc-gap5">

<div>

- 🦥 Random mutation <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🧐 Higher order mutation <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🏎️ Parallel execution <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🦥 Data-flow analysis <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🦥 Control-flow analysis <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🧐 Minimization and prioritization of test sets <!-- .element: class="fragment fade-in-then-semi-out" -->

</div>
<div>

- 🦥 Constrained mutation <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🧐 Evolutionary algorithms <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🧐 Model-based mutation <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🧐 State-based analysis <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🦥 Minimal mutation <!-- .element: class="fragment fade-in-then-semi-out" -->
- 🦥 Selective mutation <!-- .element: class="fragment fade-in-then-semi-out" -->

</div>
</div>

Note:
#### 🦥 Random mutation

> This technique selects randomly from the complete set of mutants according to a predefined probability distribution.
> Random mutation has been interpreted as "choose X% of all mutants," "for each mutant, generate it with X% probability," and as "choose X% of mutants generated by each operator".

#### 🧐 Higher order mutation

> This technique combines two or more simple mutations to create a single complex mutant.

#### 🏎️ Parallel execution

> This technique executes mutants in parallel processors, reducing the total time needed to perform mutation analysis.

#### 🦥 Data-flow analysis

> This technique uses program data-flow-related information to decide which mutants to generate and to analyze mutants.
> It considers whether variables that are more prone to failure during execution are reached and referenced.

#### 🦥 Control-flow analysis

> This technique uses program control flow-related information, focusing on execution characteristics to identify branches and commands that help determine which structures are most relevant to the generation and execution of mutants.

#### 🧐 Minimization and prioritization of test sets

> This technique analyzes the test suite to score test cases based on their effectiveness at killing mutants, then either eliminates test cases that are ineffective or runs the most effective test cases before the less effective test cases.

#### 🦥 Constrained mutation

> This technique chooses a subset of mutation operators to use.
> The choice relies on testers' intuition regarding the significance of particular groups of mutants.

#### 🧐 Evolutionary algorithms

> This technique uses evolutionary algorithms to reduce the number of mutants, to reduce the number of test cases, or to identify equivalent mutants.

#### 🧐 Model-based mutation

> This technique mutates formal or informal models of the program, and then uses the mutants to automatically generate test cases that are later used to kill mutants of the program.

#### 🧐 State-based analysis

> This technique compares states of different mutant executions.
> When two mutants lead to the same mutation state, that is, when the same execution path is observed, only one needs to be executed and the result of the other can be inferred.
> Similarly, the technique creates groups of classes that deffne certain transition sequences such that only one needs to be verified.

#### 🦥 Minimal mutation

> This technique identifies and eliminates redundant mutants by applying the concepts of mutant subsumption and dominator mutants.

#### 🦥 Selective mutation

> This technique tries to avoid the application of mutation operators that are responsible for the most mutants or to select mutation operators that result in mutants that are killed by tests that also kill lots of mutants created by other operators.
> The idea is that if a test set T<sub>op</sub>, that is adequate for a subset of mutation operators M<sub>op</sub>, also kills a very high percentage of all mutants, then we can select only the operators in M<sub>op</sub>

---

![](/img/callisto.png)
<!-- .element: style="text-align: center" -->

---

### Callisto

Selective mutation approach by Info Support's Jan Smits

Uses an initial run of mutation testing to find a trade off between accuracy and run time

Summary: https://research.infosupport.com/publications/callisto-selecting-effective-mutation-operators-for-mutation-testing/ \
Thesis: https://essay.utwente.nl/89294/
<!-- .element: class="kc-smaller" -->
